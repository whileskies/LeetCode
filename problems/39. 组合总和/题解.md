### 题目信息

名称：39. 组合总和

链接：https://leetcode-cn.com/problems/combination-sum/

难度：中等

标签：数组、回溯算法

### 题目描述

给定一个**无重复元素**的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

**提示：**

- 1 <= candidates.length <= 30
- 1 <= candidates[i] <= 200
- candidate 中的每个元素都是独一无二的。
- 1 <= target <= 500

### 方法：回溯

##### 思路

求目标为7的组合，若组合包含2，则问题转换为求目标为7 - 2 = 5的组合；若组合包含3，则问题转换为求目标为7 - 3 = 4的组合；这样，原问题转化为相同的子问题，该过程可用搜索树来表示：

![image-20200902154031052](https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20200902154038.png)

1. 当目标为0时，从树根到树叶的路径中依次所减去的数为一个结果组合，如[2, 2, 3]、[2, 3, 2]、[7]；
2. 为了使得结果组合不重复，可以按字典序的顺序进行搜索，也即先将candidates 数组排序，每次选择分支进入时按照排序的顺序，这样生成的结果也是有序的，如[2, 3, 2]被过滤；
3. 当目标为负数时，沿该路径已经无法找到结果，退出该路径的搜索；
4. 若能提前判断一个路径无法得到结果，可对该路径进行剪枝，无需继续搜索；如目标值为5时，将开始尝试搜索目标值为5 - 6 = -1的组合，此时已经可直接跳过该分支，而且因为是递增搜索的，candidates 中6之后的分支均可跳过，提高执行效率。

##### 代码

```java
import java.util.*;

public class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();

        dfs(candidates, target, 0, path, res);

        return res;
    }

    public void dfs(int[] candidates, int target, int start, Deque<Integer> path, List<List<Integer>> res) {
        if (target == 0) {
            res.add(new ArrayList<>(path));
        } else if (target > 0) {
            for (int i = start; i < candidates.length; i++) {
                if (candidates[i] > target)
                    break;
                path.addLast(candidates[i]);
                dfs(candidates, target - candidates[i], i, path, res);
                path.removeLast();
            }
        }
    }


    public static void main(String[] args) {
        int[] candidates = new int[]{2, 3, 6, 7};
        Solution s = new Solution();
        List<List<Integer>> ret = s.combinationSum(candidates, 7);

        for (List<Integer> list : ret) {
            System.out.println(list);
        }
    }
}
```