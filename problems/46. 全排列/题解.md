### 题目信息

名称：46. 全排列

链接：https://leetcode-cn.com/problems/permutations/

难度：中等

标签：回溯算法

### 题目描述

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

示例:

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 方法：回溯法

##### 思路

共三位数的排列，依次尝试每一位应放置的数，如第一个位置可以放置[1]、[2]、[3]，在[1]的基础上，第二位可以放置[1,2]、[1,3]，只要保证每一排列结果使用的数字不重复即可，该过程可形成如下树状图：

<img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20200903103412.png" alt="image-20200903103412517" style="zoom:67%;" />

因此可以将该树状图作为搜索树，进行dfs搜索，从树根到树叶的路径为一个排列。

每一个结点都是一个状态，当一个状态结点之下的所有状态均搜索完成后，则回溯到该状态结点的上一结点，尝试其他可能的状态。

当回溯的之前的结点时，应进行状态重置，重新在该状态的基础上寻找可能的下一状态。

##### 代码

```java
import java.util.*;

public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();

        boolean[] visited = new boolean[nums.length];

        dfs(nums, visited, path, res);

        return res;
    }

    public void dfs(int[] nums, boolean[] visited, Deque<Integer> path, List<List<Integer>> res) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (!visited[i]) {
                visited[i] = true;
                path.addLast(nums[i]);
                dfs(nums, visited, path, res);
                visited[i] = false;
                path.removeLast();
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3};
        Solution s = new Solution();
        List<List<Integer>> res = s.permute(nums);

        for (List<Integer> list : res) {
            System.out.println(list);
        }
    }
}
```